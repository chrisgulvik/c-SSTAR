#!/usr/bin/env python

__version__ = '1.3.0'

import argparse
import logging
import os
import pwd
import re
import subprocess
import sys
from multiprocessing import cpu_count

from Bio.Seq import Seq
from Bio.Alphabet import generic_dna

def parse_args():
	parser = argparse.ArgumentParser(description='c-SSTAR is a CLI utility'
		' for rapidly identifying antibiotic resistance gene determinants in'
		' bacterial genomes')
	parser.add_argument('-d', '--database', required=True, metavar='FILE',
		help='a SSTAR-formatted FastA database of AR gene sequences')
	parser.add_argument('-g', '--genome', required=True, metavar='FILE',
		help='a FastA genome')
	parser.add_argument('-b', '--basename', type=str, metavar='STR',
		help='output file prefix')
	parser.add_argument('-c', '--cpus', type=int, metavar='INT',
		default=cpu_count(),
		help='number of threads for BLASTn to use [default: %(default)s]')
	parser.add_argument('-o', '--outdir', type=str, metavar='PATH',
		default=os.getcwd(),
		help='output directory [default: cwd]')
	parser.add_argument('-s', '--similarity', type=int, metavar='INT',
		default=95,
		help='minimum percent nucleotide similarity [default: %(default)s]')
	parser.add_argument('-e', '--edge', type=int, default=50, metavar='INT',
		help='number of bases at each contig edge to report as \'$\''
		' for end [default %(default)s]')
	parser.add_argument('-v', '--version', action='version',
		version='%(prog)s v{}'.format(__version__))
	return parser.parse_args()

def sys_call(syscmd):
	'''runs a system command string in a subshell and exits with an error
	message if the return code of the command was anything other than 0'''
	with open(os.devnull) as dump: 
		returncode = subprocess.call(syscmd, stdout=dump, stderr=dump,
			shell=True)
		if returncode != 0:
			logging.error('failed sys_call ' + syscmd)
			sys.stderr.write('ERROR: failed sys_call {}\n'.format(syscmd))
			sys.exit(1)

def require_file_exists_and_test_empty(infile):
	'''determines if an input file is present and exits with error message if
	untrue; returns whether the file is empty'''
	if os.path.exists(infile):
		if os.stat(infile).st_size == 0:
			return True
		return False
	else:
		sys.stderr.write('ERROR: {} file absent\n'.format(infile))
		sys.exit(1)

def translate_seq(nuclSeq):
	'''use biopython to take in a nucleotide sequence (string) and
	return a protein sequence'''
	proteinSeq = Seq(nuclSeq, generic_dna).translate(cds=False, to_stop=False,
		stop_symbol='*')
	return proteinSeq

def search_for_internal_stop_codon(candidate):
	'''counts number of internal stop codons; requires sequence from database
	to be in frame'''
	if '-' in candidate[11]:
		nucSeq = candidate[11].replace('-', '')
	else:
		nucSeq = candidate[11]
	if int(int(candidate[8]) % 3) == 1:
		frameStart = int(0)
	elif int(int(candidate[8]) % 3) == 0:
		frameStart = int(1)
	elif int(int(candidate[8]) % 3) == 2:
		frameStart = int(2)
	if frameStart > 0:
		nucSeq = nucSeq[frameStart:]
	if len(nucSeq) % 3 == 0:
		protein = translate_seq(nucSeq)
	elif len(nucSeq) % 3 > 0:
		protein = translate_seq(nucSeq[:-(len(nucSeq) % 3)])
	else:
		sys.stderr.write('ERROR: incorrect nucleotide length ({}) after'
		' trimming\n'.format(len(nucSeq)))
		sys.exit(1)
	numInternalSTOPcodons = len(re.findall(r'\*[ABCDEFGHIKLMNPQRSTVWYZ]',
		str(protein)))
	return (protein, str(numInternalSTOPcodons))

def tag_hit(l, edge):
	'''evaluates the alignment list l and returns a new list containing
	shorthand labels denoting if an allele match was not full length or <100%,
	if the alignment was at the edge of a contig, and if any internal stop
	codons were predicted in the alignment'''
	if int(l[5]) != int(l[7]):
		# incomplete length; SRST2='? indicates that there was 
		#   uncertainty in at least one of the alleles'
		l = [l[0], l[1]+'?', l[2]+'?'] + l[3:13]
	if int(l[5]) == int(l[7]) and int(l[4]) < 100:
		# full length match but pident!=100%
		# SRST2='* [...] indicates that there were mismatches against at least
		#   one of the alleles. This suggests that you have a novel variant
		#   [...] rather than a precise match'
		l = [l[0], l[1]+'*', l[2]+'*'] + l[3:13]
	if (int(l[8]) - edge) < 0:
		# edge hits on left edge
		if (int(l[7]) - int(l[9])) > 0:
			# incomplete alignlen at edge for '$' designation
			#   distinguishing ^ from $ is unnecessary
			l = [l[0], l[1]+'$', l[2]+'$'] + l[3:13]
	if (int(l[9]) + edge) > int(l[10]): 
		# edge hits on right edge
		if (int(l[7]) + int(l[8])) > int(l[10]):
			# require incomplete alignlen
			l = [l[0], l[1]+'$', l[2]+'$'] + l[3:13]
	(prot, numSTOP) = search_for_internal_stop_codon(l)
	if int(numSTOP) > 0:
		# TR indicates 'truncated protein translation'
		l = [l[0], l[1]+'TR', l[2]+'TR'] + l[3:13]
	return l

def main():
	args = parse_args()
	outdir = os.path.realpath(os.path.expanduser(args.outdir))
	genome = os.path.realpath(os.path.expanduser(args.genome))
	database = os.path.realpath(os.path.expanduser(args.database))
	similarity = args.similarity
	if args.basename is not None:
		baseGenome = args.basename
	else:
		baseGenome = os.path.splitext(os.path.basename(genome))[0]
	if not os.path.exists(outdir): 
		os.mkdir(outdir)
	logging.basicConfig(
		filename=os.path.join(outdir, 'c-SSTAR_{}.log'.format(baseGenome)),
		format='%(asctime)s: %(levelname)s: %(message)s',
		datefmt='%d-%m-%Y %I:%M:%S %p', level=logging.INFO)
	logging.info('c-SSTAR version: {}'.format(__version__))
	logging.info('user: {}'.format(pwd.getpwuid(os.getuid()).pw_name))
	logging.info('release: {}'.format(os.uname()[3]))
	logging.info('shell env: {}'.format(pwd.getpwuid(os.getuid()).pw_shell))
	logging.info('cwd: {}'.format(pwd.getpwuid(os.getuid()).pw_dir))
	logging.info('python version: {}'.format(sys.version))
	logging.info(subprocess.check_output(
		'command -v blastn', shell=True).rstrip())
	logging.info(subprocess.check_output(
		'blastn -version | tail -n 1', shell=True).rstrip())
	sys_call('makeblastdb -in {} -out {} -dbtype nucl'.format(
		genome, os.path.join(outdir, baseGenome)))
	for x in ['.nin', '.nsq', '.nhr']:
		empty = require_file_exists_and_test_empty(os.path.join(outdir,
			baseGenome + x))
		if empty:
			sys.stderr.write('ERROR: failed making BLAST database to'
				' search\n{} file empty\n'.format(
				os.path.join(outdir, baseGenome + x)))
			sys.exit(1)
	sys_call('blastn -task blastn -query {0} -db {out} -out {out}.blastn.tsv'
		' -evalue 1e-5 -max_target_seqs 1 -perc_identity {1} -culling_limit 1'
		' -outfmt "6 qseqid sseqid pident length mismatch gaps qstart qend'
		' sstart send evalue bitscore qlen slen sseq" -num_threads {2}'.\
		format(database, similarity, args.cpus,
			out=os.path.join(outdir, baseGenome)))
	for x in ['.nin', '.nsq', '.nhr']:
		os.remove(os.path.join(outdir, baseGenome + x))
	empty = require_file_exists_and_test_empty(os.path.join(outdir,
		baseGenome + '.blastn.tsv'))
	if empty:
		sys.stderr.write('INFO: no antimicrobial resistance genes detected\n')
		sys.exit(0)
	with open(os.path.join(outdir, baseGenome + '.blastn.tsv')) as infile:
		best = ['-1','a','a','a',0,'-1','a',0,'a','a',0,'a']
		currentClusterNr = '-1'
		topHits = []
		for l in infile:
			blastOut = [x for x in l.split('\t')]
			thresHold = (int(blastOut[12]) / 5 ) * 2
			if int(blastOut[3]) > thresHold:
				enzymeParts = [s for s in blastOut[0].split('__')]
				clusterNr = enzymeParts[0]
				ident, dec = blastOut[2].split('.')
				pident = int(ident)
				bitscore = blastOut[11]
				candidate = [clusterNr, enzymeParts[1], enzymeParts[2],
					blastOut[1], pident, blastOut[3], bitscore, blastOut[12],
					blastOut[6], blastOut[7], blastOut[13],
					blastOut[14].rstrip()]
				if clusterNr == currentClusterNr:
					if float(best[6]) < float(candidate[6]):
						best = candidate
				else:
					if best[4] >= similarity:
						topHits.append(best)
					currentClusterNr = clusterNr
					best = candidate
		if best[4] >= similarity:
			topHits.append(best)
	for i in topHits:
		hit = tag_hit(i, args.edge)
		print(hit[1] + '\t' + hit[2] + '\t' + hit[3] + '\t' +
			str(hit[4]) + '%\t' + str(hit[5]) + '\t' + str(hit[7]))

if __name__ == '__main__':
	main()
